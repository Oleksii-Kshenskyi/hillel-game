1. Ми пишемо текстову гру. 
2. Технології будуть включати в себе: git/GitHub, C++, CMake, Conan (Python), fmt, nlohmann-json.
3. Ми будемо писати текстову гру тому, що:
- Практика у написанні модульного коду і розумінні структури програми;
- Розуміти не тільки написання С++ коду, але і мати розуміння інфрастуктури типового С++-проєкту.
Нажаль, С++-проєкт не складається лише з власне С++-коду. С++ зазвичай має полягатися на доволі складні білд-системи та інфраструктуру, тому що навідміну від більш сучасних около-системних мов типу Rust або Go, С++ не має стандартизованого управління пакетами та структурою проєкта, тому кожний проєкт - це виходить свій міні-всесвіт, який робить по-своєму.
- Практичне вміння переносити ідею програми у код, а таким чином і у реальне життя.

ЗАЛЕЖНОСТІ, ТРЕБА ВСТАНОВИТИ ВЛАСНОРУЧ:
- gcc >= 13
- cmake >= 3.26.0
- ninja >= 1.11.0
- python >= 3.12
- Visual Studio 2022 або Xcode якщо вам потрібно.

Простіше за все встановити ці речі за допогою brew на Mac та scoop на Windows.

Модульність коду - це здатність коду бути розбитим на декілька різних частин, котрі вірним чином взаємодіють одне з одним, утворюючи одну цілу програму.
Монолітна програма - це "програма - одна цегла". Це програма, у якої всі "внутрішні органи" звʼязані в один ком, у неї немає "початку, середини та кінця", вона просто перемішана у одне ціле. Такі програми майже неможливо адекватно підтримувати на протязі довгого часу, і майже неможливо фіксити у ниг баги та додавати нові фічі. Спагетті-код.
Модульна програма - це те, як у реальності побудована, скажімо, людина. Коли у вас є безліч різних органів та клітин, які роблять свою незалежну функцію, але є при цьому частиною єдиного цілого, яка виконує важливу функцію у більшій системі, ніж сам орган. Так само і модульна програма, вона складається з декількох незалежних елементів, які повинні коректним чином взаємодіяти одне з одним для того, щоб правильно виконувати спільне завдання програми.

ПЛАН НА ЗАНЯТТЯ
1. Налаштування гіт-репозиторію.
2. Налаштування компіляції програми за допомогою базового CMake-файлу.
3. Додання зовнішніх залежностей до проєкту (у нас їх дві, fmt та nlohmann-json) для простішого написання нашої гри.
fmt - це популярна С++ бібліотека для структурованого виводу інформації на екран. fmt має більше можливостей, ніж стандартний printf/cout, воно надає вам помилки ще на етапі компіляції, та вона має можливість давати вам набагато більш зрозумілі помилки, ніж printf/cout. Ми будемо в основному використовувати fmt для структурованого виводу на екран і для кросплатформеного кольорового виводу на екран.
nlohmann-json - це найпопулярніша С++-бібліотека для серіалізації С++-даних, яка серіалізує в і десереалізує з JSON формату.
Серіалізація - це процес переведення якихось даних у С++ (допустимо строки, або числа, або користувацького класу або типу даних) з власне форми даних у памʼяті у строку або текст, а згодом зачасту і в файл. Це потрібно для збереження даних між сесіями гри, тобто "save файли".

git - це універсальний кросплатформений інструмент для "версіювання" коду. Мається на увазі можливість розробки коду декількома людьми одночасно, можливість відкатуватися на попередні версії коду, якщо щось пішло не так, та можливість за допомогою типу сервісів GitHub/GitLab дуже просто переносити код з системи на систему.

CMake - це "білд-система" та "генератор білд-файлів".
У сфері С++ немає універсального способу зкомпілювати архітектурно складний проєкт. Для того, щоб зкомпілювати та коректно зібрати великий проект, зачасту потрібна ціла система автоматизації. Ця система автоматизація, яка автоматично компілює ("білдить") та зачасту навіть встановлює ваш додаток і називається білд-системою. 
Генератором білд-файлів CMake називається тому, що він здатний генерувати білд-файли (типу проєктних файлів .vcxproj на Visual Studio та .xcodeproj у Xcode) для різних IDE та систем, і на дуже великій кількості операційних систем.

Conan - "менеджер пакетів". Це програма (написана та розповсюджувана за допомогою Python), яка дозволяє автоматично та коректно встановлювати коректні версії третьосторонніх бібліотек. Це значить, що наші бібліотеки fmt та nlohmann-json ми будемо "тягнути" з conan.

Такі генератори можуть бути корисні вам у CMake:
- Unix Makefiles - це звичайні юніксові мейкфайли, які компілюються потім, після генерації, однією командою make.
- MINGW Makefiles - це те саме, що і Unix Makefiles, тільки для Windows.
- Ninja - це дуже схожа білд-система на make, але це набагато більш кросплатформений та універсальний варіант, написаний Google відверто з ціллю кросплатформеної та крос-інструментарної компіляції.
- Visual Studio 17 2022 - це генератор Віжуал Студії, доступний тільки на Вінді. Зачасту на Вінді працює ідеально, тому якщо ви працюєте тільки там - цей генератор буде для вас добрим вибором.
- Xcode - це генератор, призначений для ідентичного досвіду, як Visual Studio на Вінді, але нажаль з ним бувають проблеми. Тому якщо зберетеся його використовувати, можливо доведеться гуглити або питати мене :)

Базові програми для встановлення Conan:
- Conan встановлюється за допомогою менеджера пакетів pip - це дефолтний менеджер пакетів у Python. Тобто з тих пір, як ви встановили сам Python, pip в вас вже теж буде, і його окремо встановлювати не треба.
- python -m venv venv - створення віртуального середовища
- chmod +x venv/bin/* - тільки для Mac/Linux - це робить всі файли у директорії bin виконуваними. Це значить що без цієї команди ви не зможете виконати файли, які є у вашому віртуальному середовищі.
- source venv/bin/activate
- pip install conan - це власне команда, яка інсталює сам Conan, яким ми будемо користуватися.
- conan profile detect - команда, яка намагається автоматично визначити та прописати дефолтний профіль, за яким буде працювати Conan. Він включає тип вашої операційної системи, архітектуру, компілятор С++ який буде використовувати Conan і так далі.

ТЕКСТОВА ГРА:
- Це гра, у якій немає графіки, видача команд гравцем та реакція на команди програмою відбуваються виключно текстом.
- Середовище, яке у циклі сприймає команди від гравця (користувача), якимось чином їх обробляє та видає на екран результат.
- У нашій грі у нас будуть: гравець, кімнати, по яких можна ходити, інвентар гравця та монстри, з якими можна битись.
- У нас будуть базові команди для наступних речей:
-- Піти на: північ, південь, схід, захід;
-- Подивитися на свій інвентар;
-- Подивитися на свою кількість HP;
-- Команди для того, щоб битися з монстрами.
- Кожна різна функціональність у нашій програмі буде виділена в окремий клас, який буде якимось чином взаємодіяти з іншими класами. Шляхом цієї міжкласової взаємодії і буде функціонувати вся програма.

План на наступні заняття:
1. Гравець, його основні параметри та можливість подивитися ці параметри всередині гри.
-- Основні параметри гравця це його HP, його інвентар та його поточна локація.

2. Кімнати, генерація якоїсь невеличкої мапи та переміщення гравця між кімнатами.
-- Основні параметри кімнат: назва, опис, "інвентар" кімнати, або те що у ній лежить.

3. Інвентар гравця. Це те, що гравець має при собі та плюс все те, що гравець назбирав за дану гру.
-- Інвентар гравця (допустимо вектор, який зберігає у собі все, що з собою носить гравець)
-- Випадкова генерація всих можливих предметів (тих що можна покласти у інветра) у кімнатах.
-- Реалізувати дію цих предметів при їх використанні.

4. Монстри - це сутність, яка автоматично (випадково) генерується у кімнаті, коли ти туди заходиш, і вони атакують тебе до тих пір, поки або вони, або ти не помрете.
-- Монстр буде дуже простою сутністю, у якої є якесь значення атаки, і він покроково з вами бʼє вас допоки ви або монстр не загинете;
-- Коли монстр помирає, це можна трактувати або як "перемогу" у грі, або з нього щось корисне буде падати і т.д.

ІТЕРАТИВНИЙ ПІДХІД ДО РОЗРОБКИ ПРОГРАМ:
1. Ітерація - це один крок на шляху до "завершення". Допустимо це один крок у циклі. Якщо у вас цикл значень і з 1 до 10, то і = 5 або і = 1 це одна ітерація.
2. Ітеративний підхід (до розрозбки будь-якої програми): це підхід "покроковий". Або підхід "маленькими кроками до великої цілі".
2.5. Ітеративний підхід має на увазі повільне просування від простого до складного.
3. Коли ви розробляєте програму, особливо велику, найбільше значення має: не поспішати та не "відкусувати більше, ніж можете прожувати". Тобто рухайтеся впреред невеликими кроками. І рухайтеся далі тільки у тому випадку, якщо ви впевнені, що даний крок працює так, як ви хочете.

Технічний борг - це ситуація, котра виникає, коли у ітеративному процесі розробники рухаються значно швидше, ніж потрібно, і на кожному окремому кроці приділяють цьому кроку набагато менше уваги, ніж він заслуговує. Технічний борг зачасту полягає у архітектурі, яка здатна пітримати просту або тривіальну програму, але ламається та втрачає свою гнучкість, коли програма росте.


=> go north
=> go south
=> show inventory
=> show hp
=> attack monster

REPL - Read-Eval Print Loop - цикл читання-обчислення-друку